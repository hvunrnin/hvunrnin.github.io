---
title: "[백준] 컵라면"
author: "hvunrnin"
date: 2025-06-25 10:00:00 
categories: [Algorithm, Java]
tags: [Algorithm, Java]
math: true
toc: true
pin: true
---

## 문제
백준 1781. 컵라면

### 문제
상욱 조교는 동호에게 N개의 문제를 주고서, 각각의 문제를 풀었을 때 컵라면을 몇 개 줄 것인지 제시 하였다. 하지만 동호의 찌를듯한 자신감에 소심한 상욱 조교는 각각의 문제에 대해 데드라인을 정하였다.

동호가 2, 6, 3, 1, 7, 5, 4 순으로 숙제를 한다면 2, 6, 3, 7번 문제를 시간 내에 풀어 총 15개의 컵라면을 받을 수 있다.
문제는 동호가 받을 수 있는 최대 컵라면 수를 구하는 것이다. 위의 예에서는 15가 최대이다.

문제를 푸는데는 단위 시간 1이 걸리며, 각 문제의 데드라인은 N이하의 자연수이다. 또, 각 문제를 풀 때 받을 수 있는 컵라면 수와 최대로 받을 수 있는 컵라면 수는 모두 231보다 작은 자연수이다.

예를 들어 백준이가 동생에게 1, 5, 2, 10, -99, 7, 5를 순서대로 외쳤다고 하면, 동생은 1, 1, 2, 2, 2, 2, 5를 차례대로 말해야 한다. 백준이가 외치는 수가 주어졌을 때, 동생이 말해야 하는 수를 구하는 프로그램을 작성하시오.

### 입력
첫 줄에 숙제의 개수 N (1 ≤ N ≤ 200,000)이 들어온다. 다음 줄부터 N+1번째 줄까지 i+1번째 줄에 i번째 문제에 대한 데드라인과 풀면 받을 수 있는 컵라면 수가 공백으로 구분되어 입력된다.

### 출력
첫 줄에 동호가 받을 수 있는 최대 컵라면 수를 출력한다.

### 요악하면 
- 각 작업은 (마감일, 보상)으로 주어진다.
- 하루에 하나의 작업만 수행 가능하다.
- 각 작업은 마감일 이하의 날짜에만 수행 가능하다.
- 최대한 많은 보상을 얻도록 작업을 선택하자.



## 처음 시도 (단일 PriorityQueue)

우선순위 큐 하나를 활용해서 작업들을 마감일 기준 오름차순으로 정렬하고, 마감일이 같을 경우에는 보상이 더 큰 작업이 먼저 오도록 정렬했다. 이렇게 하면 각 날짜마다 가장 보상이 큰 작업만 골라서 처리할 수 있을 거라고 생각했다.

그래서 큐에서 하나를 꺼낸 뒤(poll()), 그와 같은 마감일을 가진 작업들은 나머지를 다 버려버리는 방식으로 구현했다.

```java
PriorityQueue<int[]> pq = new PriorityQueue<>(
    (a, b) -> {
        if (a[0] == b[0]) return Integer.compare(b[1], a[1]); // 마감일 같으면 보상 내림차순
        return Integer.compare(a[0], b[0]); // 마감일 오름차순
    }
);

while (!pq.isEmpty()) {
    int[] cur = pq.poll();
    answer += cur[1];
    int day = cur[0];
    while (!pq.isEmpty() && pq.peek()[0] == day) {
        pq.poll(); // 같은 마감일인 작업은 하나만 수행
    }
}
```

이렇게 했더니..

#### 틀렸다

이 방법은 같은 마감일을 가진 작업들 중 하나만 처리하고 나머지는 다 버리리는 방식이었는데 나중에 그 작업을 수행할 수 있는 기회를 완전히 차단해버리는 문제가 있었다.

마감일이 같은 작업 중 하나를 오늘 하고, 나머지는 다음 날에 여유가 있으면 그때 할 수도 있었는데, 아예 큐에서 제거해버렸기 때문에 가능한 작업을 놓치게 되었다. 하루에 하나씩 작업만 가능하다는 제약을 너무 단순하게 해석해서 불필요하게 작업을 버리는 실수를 했다.



## 바꾼 방법 (Greedy + 보상 기준 PriorityQueue)
아예 로직 자체를 바꿨다.
장 늦은 마감일부터 거꾸로 하루씩 확인하면서, 그날까지 수행할 수 있는 작업들 중 보상이 가장 높은 것 하나만 수행하도록 했다.

```java
Collections.sort(list, (a, b) -> Integer.compare(b[0], a[0])); // 마감일 내림차순

PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());
int idx = 0;
for (int day = maxDeadline; day >= 1; day--) {
    while (idx < n && list.get(idx)[0] >= day) {
        pq.add(list.get(idx)[1]); // 가능한 작업의 보상 추가
        idx++;
    }
    if (!pq.isEmpty()) {
        answer += pq.poll(); // 오늘 하루에 가장 이득인 작업 하나만 수행
    }
}

```

### 동작 방식 요약
- 가장 마감일이 늦은 날부터 하루씩 역순으로 반복한다.
- 해당 날짜 day까지 마감일이 >= day인 작업들은 모두 "오늘까지 수행 가능" 하므로 큐에 추가한다. (day가 작아지면 기존에 큐에 들어갔던 애들은 어차피 작아지는 day들보다는 무조건 크니까 상관없음)
- 이 후보들을 PriorityQueue에 보상 기준으로 넣어두면, 항상 가장 보상이 큰 작업이 맨 위에 온다.
- 하루에 하나만 작업할 수 있으므로, 매일 poll()을 딱 한 번만 호출해서 가장 이득이 되는 작업을 고른다.
- 이렇게 하면 전체 마감일 범위 내에서 가능한 최대 보상을 효율적으로 누적할 수 있었따.

